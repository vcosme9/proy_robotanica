{"version":3,"file":"PerformanceClient.js","sources":["../../../src/telemetry/performance/PerformanceClient.ts"],"sourcesContent":["/*\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\n\nimport { ApplicationTelemetry } from \"../../config/ClientConfiguration\";\nimport { Logger } from \"../../logger/Logger\";\nimport { InProgressPerformanceEvent, IPerformanceClient, PerformanceCallbackFunction } from \"./IPerformanceClient\";\nimport { IPerformanceMeasurement } from \"./IPerformanceMeasurement\";\nimport { PerformanceEvent, PerformanceEvents, PerformanceEventStatus } from \"./PerformanceEvent\";\n\nexport abstract class PerformanceClient implements IPerformanceClient {\n    protected authority: string;\n    protected libraryName: string;\n    protected libraryVersion: string;\n    protected applicationTelemetry: ApplicationTelemetry;\n    protected clientId: string;\n    protected logger: Logger;\n    protected callbacks: Map<string, PerformanceCallbackFunction>;\n    \n    /**\n     * Multiple events with the same correlation id.\n     * Double keyed by correlation id and event id.\n     * @protected\n     * @type {Map<string, Map<string, PerformanceEvent>>}\n     */\n    protected eventsByCorrelationId: Map<string, Map<string, PerformanceEvent>>;\n    \n    /**\n     * Underlying performance measurements for each operation\n     *\n     * @protected\n     * @type {Map<string, IPerformanceMeasurement>}\n     */\n    protected measurementsById: Map<string, IPerformanceMeasurement>;\n    \n    /**\n     * Creates an instance of PerformanceClient, \n     * an abstract class containing core performance telemetry logic.\n     *\n     * @constructor\n     * @param {string} clientId Client ID of the application\n     * @param {string} authority Authority used by the application\n     * @param {Logger} logger Logger used by the application\n     * @param {string} libraryName Name of the library\n     * @param {string} libraryVersion Version of the library\n     */\n    constructor(clientId: string, authority: string, logger: Logger, libraryName: string, libraryVersion: string, applicationTelemetry: ApplicationTelemetry) {\n        this.authority = authority;\n        this.libraryName = libraryName;\n        this.libraryVersion = libraryVersion;\n        this.applicationTelemetry = applicationTelemetry;\n        this.clientId = clientId;\n        this.logger = logger;\n        this.callbacks = new Map();\n        this.eventsByCorrelationId = new Map();\n        this.measurementsById = new Map();\n    }\n    \n    /**\n     * Starts and returns an platform-specific implementation of IPerformanceMeasurement.\n     *\n     * @abstract\n     * @param {string} measureName\n     * @param {string} correlationId\n     * @returns {IPerformanceMeasurement}\n     */\n    abstract startPerformanceMeasuremeant(measureName: string, correlationId: string): IPerformanceMeasurement;\n    \n    /**\n     * Generates and returns a unique id, typically a guid.\n     *\n     * @abstract\n     * @returns {string}\n     */\n    abstract generateId(): string;\n    \n    /**\n     * Starts measuring performance for a given operation. Returns a function that should be used to end the measurement.\n     *\n     * @param {PerformanceEvents} measureName\n     * @param {?string} [correlationId]\n     * @returns {InProgressPerformanceEvent}\n     */\n    startMeasurement(measureName: PerformanceEvents, correlationId?: string): InProgressPerformanceEvent {\n        // Generate a placeholder correlation if the request does not provide one\n        const eventCorrelationId = correlationId || this.generateId();\n        if (!correlationId) {\n            this.logger.info(`PerformanceClient: No correlation id provided for ${measureName}, generating`, eventCorrelationId);\n        }\n\n        this.logger.trace(`PerformanceClient: Performance measurement started for ${measureName}`, eventCorrelationId);\n        const performanceMeasurement = this.startPerformanceMeasuremeant(measureName, eventCorrelationId);\n        performanceMeasurement.startMeasurement();\n\n        const inProgressEvent: PerformanceEvent = {\n            eventId: this.generateId(),\n            status: PerformanceEventStatus.InProgress,\n            authority: this.authority,\n            libraryName: this.libraryName,\n            libraryVersion: this.libraryVersion,\n            appName: this.applicationTelemetry?.appName,\n            appVersion: this.applicationTelemetry?.appVersion,\n            clientId: this.clientId,\n            name: measureName,\n            startTimeMs: Date.now(),\n            correlationId: eventCorrelationId\n        };\n\n        // Store in progress events so they can be discarded if not ended properly\n        this.cacheEventByCorrelationId(inProgressEvent);\n        this.cacheMeasurement(inProgressEvent, performanceMeasurement);\n\n        // Return the event and functions the caller can use to properly end/flush the measurement\n        return {\n            endMeasurement: (event?: Partial<PerformanceEvent>): PerformanceEvent | null => {\n                const completedEvent = this.endMeasurement({\n                    // Initial set of event properties\n                    ...inProgressEvent,\n                    // Properties set when event ends\n                    ...event\n                });\n    \n                if (completedEvent) {\n                    // Cache event so that submeasurements can be added downstream\n                    this.cacheEventByCorrelationId(completedEvent);\n                }\n    \n                return completedEvent;\n            },\n            flushMeasurement: () => {\n                return this.flushMeasurements(inProgressEvent.name, inProgressEvent.correlationId);\n            },\n            discardMeasurement: () => {\n                return this.discardMeasurements(inProgressEvent.correlationId);\n            },\n            measurement: performanceMeasurement,\n            event: inProgressEvent\n        };\n        \n    }\n    \n    /**\n     * Stops measuring the performance for an operation. Should only be called directly by PerformanceClient classes,\n     * as consumers should instead use the function returned by startMeasurement.\n     *\n     * @param {PerformanceEvent} event\n     * @returns {(PerformanceEvent | null)}\n     */\n    endMeasurement(event: PerformanceEvent): PerformanceEvent | null {\n        const performanceMeasurement = this.measurementsById.get(event.eventId);\n        if (performanceMeasurement) {\n            // Immediately delete so that the same event isnt ended twice\n            this.measurementsById.delete(event.eventId);\n            performanceMeasurement.endMeasurement();\n            const durationMs = performanceMeasurement.flushMeasurement();\n            // null indicates no measurement was taken (e.g. needed performance APIs not present)\n            if (durationMs !== null) {\n                this.logger.trace(`PerformanceClient: Performance measurement ended for ${event.name}: ${durationMs} ms`, event.correlationId);\n    \n                const completedEvent: PerformanceEvent = {\n                    // Allow duration to be overwritten when event ends (e.g. testing), but not status\n                    durationMs: Math.round(durationMs),\n                    ...event,\n                    status: PerformanceEventStatus.Completed,\n                };\n        \n                return completedEvent;\n            } else {\n                this.logger.trace(\"PerformanceClient: Performance measurement not taken\", event.correlationId);\n            }\n        } else {\n            this.logger.trace(`PerformanceClient: Measurement not found for ${event.eventId}`, event.correlationId);\n        }\n\n        return null;\n    }\n    \n    /**\n     * Upserts event into event cache.\n     * First key is the correlation id, second key is the event id.\n     * Allows for events to be grouped by correlation id,\n     * and to easily allow for properties on them to be updated.\n     *\n     * @private\n     * @param {PerformanceEvent} event\n     */\n    private cacheEventByCorrelationId(event: PerformanceEvent) {\n        const existingEvents = this.eventsByCorrelationId.get(event.correlationId);\n        if (existingEvents) {\n            this.logger.trace(`PerformanceClient: Performance measurement for ${event.name} added/updated`, event.correlationId);\n            existingEvents.set(event.eventId, event);\n        } else {\n            this.logger.trace(`PerformanceClient: Performance measurement for ${event.name} started`, event.correlationId);\n            this.eventsByCorrelationId.set(event.correlationId, new Map().set(event.eventId, event));\n        }\n    }\n    \n    /**\n     * Cache measurements by their id.\n     *\n     * @private\n     * @param {PerformanceEvent} event\n     * @param {IPerformanceMeasurement} measurement\n     */\n    private cacheMeasurement(event: PerformanceEvent, measurement: IPerformanceMeasurement) {\n        this.measurementsById.set(event.eventId, measurement);\n    }\n    \n    /**\n     * Gathers and emits performance events for measurements taked for the given top-level API and correlation ID.\n     *\n     * @param {PerformanceEvents} measureName\n     * @param {string} correlationId\n     */\n    flushMeasurements(measureName: PerformanceEvents, correlationId: string): void {\n        this.logger.trace(`PerformanceClient: Performance measurements flushed for ${measureName}`, correlationId);\n        const eventsForCorrelationId = this.eventsByCorrelationId.get(correlationId);\n        if (eventsForCorrelationId) {\n            this.discardMeasurements(correlationId);\n            \n            /*\n             * Manually end incomplete submeasurements to ensure there arent orphaned/never ending events.\n             * Incomplete submeasurements are likely an instrumentation bug that should be fixed.\n             * IE only supports Map.forEach.\n             */\n            const completedEvents: PerformanceEvent[] = [];\n            eventsForCorrelationId.forEach(event => {\n                if (event.name !== measureName && event.status !== PerformanceEventStatus.Completed) {\n                    this.logger.trace(`PerformanceClient: Incomplete submeasurement ${event.name} found for ${measureName}`, correlationId);\n\n                    const completedEvent = this.endMeasurement(event);\n                    if (completedEvent) {\n                        completedEvents.push(completedEvent);\n                    }\n                }\n\n                completedEvents.push(event);\n            });\n\n            // Sort events by start time (earliest first)\n            const sortedCompletedEvents = completedEvents.sort((eventA, eventB) => eventA.startTimeMs - eventB.startTimeMs);\n\n            // Take completed top level event and add completed submeasurements durations as properties\n            const topLevelEvents = sortedCompletedEvents.filter(event => event.name === measureName && event.status === PerformanceEventStatus.Completed);\n            if (topLevelEvents.length > 0) {\n                /*\n                 * Only take the first top-level event if there are multiple events with the same correlation id.\n                 * This greatly simplifies logic for submeasurements.\n                 */\n                if (topLevelEvents.length > 1) {\n                    this.logger.verbose(\"PerformanceClient: Multiple distinct top-level performance events found, using the first\", correlationId);\n                }\n                const topLevelEvent = topLevelEvents[0];\n\n                this.logger.verbose(`PerformanceClient: Measurement found for ${measureName}`, correlationId);\n\n                // Build event object with top level and sub measurements\n                const eventToEmit = sortedCompletedEvents.reduce((previous, current) => {\n                    if (current.name !== measureName) {\n                        this.logger.trace(`PerformanceClient: Complete submeasurement found for ${current.name}`, correlationId);\n                        // TODO: Emit additional properties for each subMeasurement\n                        const subMeasurementName = `${current.name}DurationMs`;\n                        /*\n                         * Some code paths, such as resolving an authority, can occur multiple times.\n                         * Only take the first measurement, since the second could be read from the cache,\n                         * or due to the same correlation id being used for two distinct requests.\n                         */\n                        if (!previous[subMeasurementName]) {\n                            previous[subMeasurementName] = current.durationMs;\n                        } else {\n                            this.logger.verbose(`PerformanceClient: Submeasurement for ${measureName} already exists for ${current.name}, ignoring`, correlationId);\n                        }\n                    }\n\n                    return previous;\n                }, topLevelEvent);\n\n                this.emitEvents([eventToEmit], eventToEmit.correlationId);\n            } else {\n                this.logger.verbose(`PerformanceClient: No completed top-level measurements found for ${measureName}`, correlationId);\n            }\n        } else {\n            this.logger.verbose(\"PerformanceClient: No measurements found\", correlationId);\n        }\n    }\n    \n    /**\n     * Removes measurements for a given correlation id.\n     *\n     * @param {string} correlationId\n     */\n    discardMeasurements(correlationId: string): void {\n        this.logger.trace(\"PerformanceClient: Performance measurements discarded\", correlationId);\n        this.eventsByCorrelationId.delete(correlationId);\n    }\n    \n    /**\n     * Registers a callback function to receive performance events.\n     *\n     * @param {PerformanceCallbackFunction} callback\n     * @returns {string}\n     */\n    addPerformanceCallback(callback: PerformanceCallbackFunction): string {\n        const callbackId = this.generateId();\n        this.callbacks.set(callbackId, callback);\n        this.logger.verbose(`PerformanceClient: Performance callback registered with id: ${callbackId}`);\n\n        return callbackId;\n    }\n    \n    /**\n     * Removes a callback registered with addPerformanceCallback.\n     *\n     * @param {string} callbackId\n     * @returns {boolean}\n     */\n    removePerformanceCallback(callbackId: string): boolean {\n        const result = this.callbacks.delete(callbackId);\n\n        if (result) {\n            this.logger.verbose(`PerformanceClient: Performance callback ${callbackId} removed.`);\n        } else {\n            this.logger.verbose(`PerformanceClient: Performance callback ${callbackId} not removed.`);\n        }\n        \n        return result;\n    }\n    \n    /**\n     * Emits events to all registered callbacks.\n     *\n     * @param {PerformanceEvent[]} events\n     * @param {?string} [correlationId]\n     */\n    emitEvents(events: PerformanceEvent[], correlationId: string): void {\n        this.logger.verbose(\"PerformanceClient: Emitting performance events\", correlationId);\n\n        this.callbacks.forEach((callback: PerformanceCallbackFunction, callbackId: string) => {\n            this.logger.trace(`PerformanceClient: Emitting event to callback ${callbackId}`, correlationId);\n            callback.apply(null, [events]);\n        });\n    }\n}\n"],"names":[],"mappings":"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"}